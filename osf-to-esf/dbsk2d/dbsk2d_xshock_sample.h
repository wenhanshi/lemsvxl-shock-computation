// This is brcv/shp/dbsk2d/dbsk2d_xshock_sample.h
#ifndef dbsk2d_xshock_sample_h_
#define dbsk2d_xshock_sample_h_
//:
// \file
// \brief Extrinsic shock sample
// \author Amir Tamrakar
// \date 02/15/05
//
// 
// \verbatim
//  Modifications
//   Amir Tamrakar 02/02/2005    Initial version. Conversion to VXL standard.
//
// \endverbatim

#include <vgl/vgl_point_2d.h>
#include <vbl/vbl_ref_count.h>
#include <vcl_cmath.h>
#include <vnl/vnl_math.h>
#include "dbsk2d_geometry_utils.h"

//: Extrinsic shock sample
// This class stores all the information necessary to reconstruct the 
// boundary from the shock point (i.e., all the dynamics information)
// It also stores information about the boundary points causing it
// if available in the .esf file. Although this information is redundant
// it has proven to be useful for debugging purposes.
class dbsk2d_xshock_sample : public vbl_ref_count
{
public:
  //: type of shock sample
  enum xshock_sample_type
  {
    NORMALSAMPLE='N', PRUNEDSAMPLE='P', CONTACTSAMPLE='C'
  };

  //: type of boundary relationship forming this shock point
  // this information can only be determined during compile time
  enum xshock_label_type
  { 
    BOGUS_SHOCK_LABEL,           
    REGULAR='R', SEMI_DEGENERATE = 'S', DEGENERATE = 'D', CONTACT = 'C' 
  };

  int id;                     ///> unique sample id
  vgl_point_2d<double> pt;    ///> extrinsic point
  double radius;              ///> radius (time)
  int edge_id;                ///> edge that it belongs to
  xshock_label_type label;    
  xshock_sample_type type;    ///> (N)Normal / (P)pruned junction /(C)contact junction

  //Dynamics
  double theta;               ///> tangent at the shock point
  double speed;               ///> velocity at the shock point

  // boundary information (this information is generated during compile time)
  // but can also be generated by a boundary reconstruction process

  vgl_point_2d<double> left_bnd_pt;   ///> corresponding left boundary point
  vgl_point_2d<double> right_bnd_pt;  ///> corresponding right boundary point
  double left_bnd_tangent;            ///> tangent at the left boundary point
  double right_bnd_tangent;           ///> tangent at the right boundary point

  //: Constructor
  dbsk2d_xshock_sample(int newid): vbl_ref_count(),
    id(newid), radius(-1), edge_id(-1), label(REGULAR), type(NORMALSAMPLE), 
    theta(0), speed(0){}

  //: reconstruct boundary point
  void reconstruct_boundary()
  {
    double phi;
    if (speed != 0 && speed < 99990) //100000 signals infinity
        phi = vcl_acos(-1/speed);
      else
        phi = vnl_math::pi/2;

    left_bnd_pt  = _translatePoint(pt, theta+phi, radius);
    right_bnd_pt = _translatePoint(pt,theta-phi, radius);

    left_bnd_tangent  = angle_mPiToPi(theta+phi-vnl_math::pi/2);
    right_bnd_tangent = angle_mPiToPi(theta-phi+vnl_math::pi/2);
  }

  //: Destructor
  virtual ~dbsk2d_xshock_sample() {}
};

#endif //dbsk2d_xshock_sample_h_
